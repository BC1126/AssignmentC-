@model MovieShowtimeViewModel
@{
    ViewData["Title"] = "Book Tickets - " + Model.Movie.Title;
}

@section head {
        <link rel="stylesheet" href="~/css/selectShowtime.css"/>
}

@{
    string videoId = "";

    if (!string.IsNullOrEmpty(Model.Movie.TrailerUrl))
    {
        if (Model.Movie.TrailerUrl.Contains("watch?v="))
        {
            videoId = Model.Movie.TrailerUrl.Split("v=")[1].Split("&")[0];
        }
        else if (Model.Movie.TrailerUrl.Contains("youtu.be/"))
        {
            videoId = Model.Movie.TrailerUrl.Split("youtu.be/")[1].Split("?")[0];
        }
    }
}

<!-- Movie Header with Trailer -->
<section class="movie-header">
    @{
        if (!string.IsNullOrEmpty(Model.Movie.TrailerUrl))
        {
            if (Model.Movie.TrailerUrl.Contains("watch?v="))
            {
                videoId = Model.Movie.TrailerUrl.Split("v=")[1].Split("&")[0];
            }
            else if (Model.Movie.TrailerUrl.Contains("youtu.be/"))
            {
                videoId = Model.Movie.TrailerUrl.Split("youtu.be/")[1].Split("?")[0];
            }
        }
    }
    @if (!string.IsNullOrEmpty(videoId))
    {
        <iframe id="trailerIframe"
                src="https://www.youtube.com/embed/@videoId?autoplay=1&mute=1&controls=0&loop=1&playlist=@videoId"
                frameborder="0"
                allow="autoplay; encrypted-media"
                allowfullscreen>
        </iframe>   
    }

    <div class="movie-header-overlay">

        <div class="container-custom">
            <div class="movie-info">
                <h1>@Model.Movie.Title</h1>
                <div class="movie-meta">
                    <span class="rating-badge">@Model.Movie.Rating</span>
                    <span>@Model.Movie.DurationMinutes min</span>
                    <span>@Model.Movie.Genre</span>
                </div>
                <p style="max-width: 800px; opacity: 0.9;">@Model.Movie.Description</p>
                <button id="unmuteBtn" class="unmute-btn" style="float:right;">
                    🔊 Unmute
                </button>
            </div>
        </div>
    </div>
</section>

<div class="container-custom">
    <div class="date-selector">
        <h3 class="mb-4">Select Date</h3>
        <div class="date-pills" id="datePills">
            @{
                var availableDates = Model.GroupedShowtimes
                .SelectMany(g => g.Showtimes)
                .Select(st => st.StartTime.Date)
                .Distinct()
                .OrderBy(d => d)
                .ToList();

                // Track if we've set the first pill as active
                bool firstPillSet = false;
                string initialActiveDate = "";
            }

            @foreach (var date in availableDates)
            {
                bool isActive = !firstPillSet;
                if (isActive)
                {
                    firstPillSet = true;
                    initialActiveDate = date.ToString("yyyy-MM-dd");
                }

                <div class="date-pill @(isActive ? "active" : "")"
                     data-date="@date.ToString("yyyy-MM-dd")"
                     onclick="selectDate(this)">
                    <div class="day">@date.ToString("ddd")</div>
                    <div class="date">@date.Day</div>
                    <div class="month">@date.ToString("MMM")</div>
                </div>
            }

            @if (!availableDates.Any())
            {
                <div class="alert alert-info">No upcoming showtimes available for this movie.</div>
            }
        </div>
    </div>

    <div class="d-flex align-items-center mb-3">
        <div class="form-check form-switch">
            <input class="form-check-input" type="checkbox" id="showAvailableOnly">
            <label class="form-check-label" for="showAvailableOnly" style="color: #0d0d0d !important;">Show Available Only</label>
        </div>
    </div>

    <!-- Experience Filter -->
    <div class="experience-filter">
        <button class="experience-btn active" data-type="all" onclick="filterExperience(this)">
            All Experiences
        </button>
        <button class="experience-btn" data-type="Standard" onclick="filterExperience(this)">
            Standard
        </button>
        <button class="experience-btn" data-type="Premium" onclick="filterExperience(this)">
            Premium
        </button>
        <button class="experience-btn" data-type="IMAX" onclick="filterExperience(this)">
            IMAX
        </button>
        <button class="experience-btn" data-type="4DX" onclick="filterExperience(this)">
            4DX
        </button>
    </div>

    <!-- Cinema & Showtimes -->
        < div class= "cinema-section" id = "cinemaSection" >
                @foreach(var outlet in Model.GroupedShowtimes.OrderBy(o => o.City).ThenBy(o => o.OutletName))
            {
            <div class="cinema-card">
                <div class="cinema-header">
                    <div>
                        <span class="badge bg-secondary mb-1">@outlet.City</span>
                        <div class="cinema-name">@outlet.OutletName</div>
                        <div class="cinema-location"><i class="bi bi-geo-alt"></i> @outlet.City</div>
                    </div>
                </div>

                <div class="showtime-grid">
                    @foreach (var showtime in outlet.Showtimes.OrderBy(st => st.StartTime))
                    {
                        <a href="@Url.Action("SelectTicket", "Booking", new { showtimeId = showtime.ShowTimeId })"
                           class="showtime-btn"
                           data-type="@showtime.HallType"
                           data-date="@showtime.StartTime.ToString("yyyy-MM-dd")">
                            <span class="showtime-time">@showtime.StartTime.ToString("HH:mm")</span>
                            <span class="showtime-type">@showtime.HallType</span>
                            <span class="showtime-price">RM @showtime.TicketPrice</span>
                        <span class="seat-badge">Loading...</span>
                        </a>
                    }
                </div>
            </div>
            }
        </div>
</div>

@section scripts {
    <script>
        let selectedDate = '@initialActiveDate';
        let selectedExperience = 'all';
        let availabilityData = [];
        let lastUpdateTime = null;

        function selectDate(element) {
            document.querySelectorAll('.date-pill').forEach(pill => {
                pill.classList.remove('active');
            });
            element.classList.add('active');
            selectedDate = element.dataset.date;

            // Refresh availability immediately when date changes
            refreshAvailability(true);
        }

        function filterExperience(element) {
            document.querySelectorAll('.experience-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            element.classList.add('active');
            selectedExperience = element.dataset.type;
            filterShowtimes();
        }

        function filterShowtimes() {
            const showtimes = document.querySelectorAll('.showtime-btn');
            const cinemaCards = document.querySelectorAll('.cinema-card');
            const showAvailableOnly = document.getElementById('showAvailableOnly').checked;

            cinemaCards.forEach(card => {
                const cardShowtimes = card.querySelectorAll('.showtime-btn');
                let hasVisibleShowtimes = false;

                cardShowtimes.forEach(showtime => {
                    const showtimeDate = showtime.dataset.date;
                    const showtimeType = showtime.dataset.type;
                    const isSoldOut = showtime.classList.contains('sold-out');

                    const dateMatch = showtimeDate === selectedDate;
                    const typeMatch = selectedExperience === 'all' || showtimeType === selectedExperience;
                    const availabilityMatch = !showAvailableOnly || !isSoldOut;

                    if (dateMatch && typeMatch && availabilityMatch) {
                        showtime.style.display = 'block';
                        hasVisibleShowtimes = true;
                    } else {
                        showtime.style.display = 'none';
                    }
                });

                if (hasVisibleShowtimes) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });

            // Check if any showtimes are visible
            const visibleShowtimes = document.querySelectorAll('.showtime-btn[style="display: block;"]');
            const noShowtimesMsg = document.getElementById('noShowtimesMsg');

            if (visibleShowtimes.length === 0) {
                if (!noShowtimesMsg) {
                    const msg = document.createElement('div');
                    msg.id = 'noShowtimesMsg';
                    msg.className = 'no-showtimes';
                    msg.innerHTML = '<h4>No showtimes available</h4><p>Please select a different date or experience</p>';
                    document.getElementById('cinemaSection').appendChild(msg);
                }
            } else {
                if (noShowtimesMsg) {
                    noShowtimesMsg.remove();
                }
            }
        }

        async function refreshAvailability(showNotification = false) {
            const movieId = '@Model.Movie.MovieId';

            // Update last update indicator
            updateLastRefreshIndicator(true);

            try {
                const response = await fetch(`/Booking/GetAvailability?movieId=${movieId}&date=${selectedDate}`, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch availability');
                }

                const data = await response.json();
                availabilityData = data;
                let hasChanges = false;

                data.forEach(item => {
                    const btn = document.querySelector(`.showtime-btn[href*="showtimeId=${item.showTimeId}"]`);

                    if (btn) {
                        const wasSoldOut = btn.classList.contains('sold-out');
                        const isNowSoldOut = item.isSoldOut || item.availableSeats <= 0;

                        // Detect changes
                        if (wasSoldOut !== isNowSoldOut) {
                            hasChanges = true;
                        }

                        // Remove existing badge if present
                        let badge = btn.querySelector('.seat-badge');
                        if (!badge) {
                            badge = document.createElement('span');
                            badge.className = 'seat-badge';
                            btn.appendChild(badge);
                        }

                        if (isNowSoldOut) {
                            btn.classList.add('sold-out');
                            btn.style.pointerEvents = 'none';
                            btn.style.cursor = 'not-allowed';
                            badge.textContent = 'SOLD OUT';
                            badge.style.color = '#ff4d4d';
                            badge.classList.remove('low-availability');
                        } else {
                            btn.classList.remove('sold-out');
                            btn.style.pointerEvents = 'auto';
                            btn.style.cursor = 'pointer';

                            // Show different messages based on availability
                            if (item.availableSeats <= 5) {
                                badge.textContent = `Only ${item.availableSeats} left!`;
                                badge.style.color = '#ff9800';
                                badge.classList.add('low-availability');
                            } else {
                                badge.textContent = `${item.availableSeats} seats`;
                                badge.style.color = '#4caf50';
                                badge.classList.remove('low-availability');
                            }
                        }
                    }
                });

                // Re-apply filters after updating availability
                filterShowtimes();

                // Update timestamp
                lastUpdateTime = new Date();
                updateLastRefreshIndicator(false);

                // Only show notification if explicitly requested or if there were changes
                if (showNotification && hasChanges) {
                    showToast('Availability updated - some showtimes changed!', 'info');
                }

            } catch (error) {
                console.error('Error fetching availability:', error);
                updateLastRefreshIndicator(false, true);
            }
        }

        function updateLastRefreshIndicator(isLoading, hasError = false) {
            let indicator = document.getElementById('lastUpdateIndicator');

            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'lastUpdateIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    padding: 8px 16px;
                    background: rgba(36, 36, 36, 0.95);
                    border: 1px solid #333;
                    border-radius: 20px;
                    font-size: 0.75rem;
                    color: #888;
                    z-index: 1000;
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(indicator);
            }

            if (isLoading) {
                indicator.innerHTML = '<i class="bi bi-arrow-clockwise" style="animation: spin 1s linear infinite;"></i> Updating...';
                indicator.style.borderColor = '#e50914';
                indicator.style.color = '#e50914';
            } else if (hasError) {
                indicator.innerHTML = '<i class="bi bi-exclamation-circle"></i> Update failed';
                indicator.style.borderColor = '#ff4d4d';
                indicator.style.color = '#ff4d4d';
            } else {
                const timeStr = lastUpdateTime ? formatTimeAgo(lastUpdateTime) : 'just now';
                indicator.innerHTML = `<i class="bi bi-check-circle"></i> Updated ${timeStr}`;
                indicator.style.borderColor = '#333';
                indicator.style.color = '#888';
            }
        }

        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);

            if (seconds < 10) return 'just now';
            if (seconds < 60) return `${seconds}s ago`;

            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;

            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }

        function showToast(message, type = 'info') {
            const existing = document.querySelector('.availability-toast');
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.className = 'availability-toast';
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                background: ${type === 'info' ? '#e50914' : '#4caf50'};
                color: white;
                border-radius: 8px;
                font-size: 0.9rem;
                z-index: 9999;
                animation: slideInRight 0.3s ease;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => toast.remove(), 3000);
        }

        document.getElementById('showAvailableOnly').addEventListener('change', function() {
            filterShowtimes();
        });

        let autoRefreshInterval = setInterval(() => {
            refreshAvailability(false);
        }, 30000);

        let timeUpdateInterval = setInterval(() => {
            updateLastRefreshIndicator(false);
        }, 10000);

        window.addEventListener('beforeunload', () => {
            clearInterval(autoRefreshInterval);
            clearInterval(timeUpdateInterval);
        });

        document.addEventListener("DOMContentLoaded", function() {
            refreshAvailability(false);
        });

        const iframe = document.getElementById('trailerIframe');
        const unmuteBtn = document.getElementById('unmuteBtn');

        if (unmuteBtn && iframe) {
            unmuteBtn.addEventListener('click', function () {
                if (iframe.src.includes('mute=1')) {
                    iframe.src = iframe.src.replace('mute=1', 'mute=0');
                    this.innerText = '🔇 Mute';
                } else {
                    iframe.src = iframe.src.replace('mute=0', 'mute=1');
                    this.innerText = '🔊 Unmute';
                }
            });
        }
    </script>

}
